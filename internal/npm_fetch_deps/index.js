// Variant of generate_build_file that works with new npm_fetch_deps rule
// TODO(alexeagle): maybe it wants to be factored together into one program?

const fs = require('fs');
const path = require('path');

/**
 * Create a new directory and any necessary subdirectories
 * if they do not exist.
 */
function mkdirp(p) {
  if (!fs.existsSync(p)) {
    mkdirp(path.dirname(p));
    fs.mkdirSync(p);
  }
}

async function main(args) {
  const [lockfile] = args;
  const HEADER = [
    '# Generated by fetch_npm_deps via  index2.js',
    `# Using lockfile ${lockfile}`,
    'load("@build_bazel_rules_nodejs//internal/npm_fetch_deps:npm_tarball.bzl", "npm_tarball")',
    '',
    'package(default_visibility = ["//visibility:public"])',
    '',
  ];

  const rootBuild = [...HEADER];

  const lock = JSON.parse(fs.readFileSync(lockfile));
  // Apparently the lockfile has an empty package to represent the one that was installed
  const selfpkg = lock['packages'][''];

  function readDeps(deps) {
    let result = [];
    if (!deps) return result;
    for (const [key, value] of Object.entries(deps)) {
      const nestedBuild = [...HEADER];

      const depinfo = lock['dependencies'][key];
      if (depinfo['version'].startsWith('file:')) {
        nestedBuild.push(`# Don't have a way to represent file:// packages: ${key}`);
        continue;
      }
      if (!depinfo['resolved']) {
        throw new Error('no resolved property for ' + JSON.stringify(lock['dependencies'][key]));
      }
      const tarfile = path.basename(depinfo['resolved']);
      const nestedDeps = [];
      if (!depinfo['dependencies']) {
        nestedDeps.push('# (no dependencies)');
      } else {
        nestedDeps.push(...Object.values(depinfo['dependencies'])
                            .map(v => path.basename(v['resolved']))
                            .map(v => `"//:${v}"`));
      }

      nestedBuild.push(`# dependency ${key} ${value}
npm_tarball(
   name = "${path.basename(key)}",
   src = "//:${tarfile}",
   deps = [
${nestedDeps.map(p => `        ${p},`).join('\n')}
   ],
)`);
      mkdirp(key);
      fs.writeFileSync(path.join(key, 'BUILD.bazel'), nestedBuild.join('\n'));
      result.push(`"//${key}"`);
    }
    return result
  }

  rootBuild.push(`
# dependencies listed in package.json
npm_tarball(
    name = "dependencies",
    deps = [
${readDeps(selfpkg['dependencies']).sort().map(p => `        ${p},`).join('\n')}
    ],
)`);


  rootBuild.push(`
# devDependencies listed in package.json
npm_tarball(
    name = "devDependencies",
    deps = [
${readDeps(selfpkg['devDependencies']).sort().map(p => `        ${p},`).join('\n')}
    ],
)`);

  rootBuild.push(`
exports_files([
${fs.readdirSync('.').filter(f => f.endsWith('.tgz')).map(f => `    "${f}",`).join('\n')}
])`)
  
  fs.writeFileSync('BUILD.bazel', rootBuild.join('\n'));

  return 0;
}


if (require.main == module) {
  (async () => {
    try {
      process.exitCode = await main(process.argv.slice(2));
    } catch (e) {
      console.error('FAILED', e);
      process.exitCode = 1;
    }
  })();
}
