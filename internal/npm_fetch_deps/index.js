// Variant of generate_build_file that works with new npm_fetch_deps rule
// TODO(alexeagle): maybe it wants to be factored together into one program?

const fs = require('fs');
const path = require('path');

/**
 * Create a new directory and any necessary subdirectories
 * if they do not exist.
 */
function mkdirp(p) {
  if (!fs.existsSync(p)) {
    mkdirp(path.dirname(p));
    fs.mkdirSync(p);
  }
}

async function main(args) {
  const [lockfile] = args;
  const HEADER = [
    '# Generated by fetch_npm_deps via  index2.js',
    `# Using lockfile ${lockfile}`,
    'load("@build_bazel_rules_nodejs//internal/npm_fetch_deps:npm_tarball.bzl", "npm_tarball")',
    '',
    'package(default_visibility = ["//visibility:public"])',
    '',
  ];

  const rootBuild = [...HEADER];

  const lock = JSON.parse(fs.readFileSync(lockfile));
  // Apparently the lockfile has an empty package to represent the one that was installed
  const selfpkg = lock['packages'][''];

  function readDeps(deps) {
    let result = [];
    if (!deps) return result;
    for (const [key, value] of Object.entries(deps)) {
      const nestedBuild = [...HEADER];

      const depinfo = lock['dependencies'][key];
      if (depinfo['version'].startsWith('file:')) {
        nestedBuild.push(`# Don't have a way to represent file:// packages: ${key}`);
        continue;
      }
      if (!depinfo['resolved']) {
        throw new Error('no resolved property for ' + JSON.stringify(lock['dependencies'][key]));
      }
      const tarfile = path.basename(depinfo['resolved']);
//       const nestedDeps = [];
//       if (!depinfo['dependencies']) {
//         nestedDeps.push('# (no dependencies)');
//       } else {
//         nestedDeps.push(...Object.values(depinfo['dependencies'])
//                             .map(v => path.basename(v['resolved']))
//                             .map(v => `"//:${v}"`));
//       }

//       nestedBuild.push(`# dependency ${key} ${value}
// npm_tarball(
//    name = "${path.basename(key)}",
//    src = "//:${tarfile}",
//    package_name = "${key}",
//    deps = [
// ${nestedDeps.map(p => `        ${p},`).join('\n')}
//    ],
// )`);
      

      nestedBuild.push(`
alias(
    name = "${path.basename(key)}",
    actual = "//:${path.parse(tarfile).name}",
)`);
      mkdirp(key);
      fs.writeFileSync(path.join(key, 'BUILD.bazel'), nestedBuild.join('\n'));
      result.push(`"//${key}"`);
    }
    return result
  }

  rootBuild.push(`
# Shorthand target to get all dependencies listed in package.json
npm_tarball(
    name = "dependencies",
    deps = [
${readDeps(selfpkg['dependencies']).sort().map(p => `        ${p},`).join('\n')}
    ],
)`);


  rootBuild.push(`
# Shorthand target to get all devDependencies listed in package.json
npm_tarball(
    name = "devDependencies",
    deps = [
${readDeps(selfpkg['devDependencies']).sort().map(p => `        ${p},`).join('\n')}
    ],
)`);

//   rootBuild.push(`
// # Allow any tar file to be referenced from some other package??
// exports_files([
// ${fs.readdirSync('.').filter(f => f.endsWith('.tgz')).map(f => `    "${f}",`).join('\n')}
// ])`)
  
  const writtenDeps = []
  function writeRulesForDeps(deps) {
    if (!deps) return;
    Object.entries(deps).forEach(([pkg, pkginfo]) => {
      if (pkginfo['version'].startsWith('file:')) {
        rootBuild.push(`# Don't have a way to represent file:// packages: ${pkg}`);
        return;
      }
      const nestedDeps = [];
      if (!pkginfo['dependencies']) {
        nestedDeps.push('# (no dependencies)');
      } else {
        nestedDeps.push(...Object.entries(pkginfo['dependencies'])
                            .map(([k,v]) => `${k.replace("/", "-")}-${v['version']}`)
                            .map(v => `"//:${v}"`));
      }
      writeRulesForDeps(pkginfo['dependencies']);
      const rulename = pkg.replace("/", "-") + '-' + pkginfo['version']
      if (!writtenDeps.includes(rulename)) {
        writtenDeps.push(rulename)
        rootBuild.push(`
npm_tarball(
    name = "${rulename}",
    src = "${pkg.replace("/", "-")}-${pkginfo['version']}.tgz",
    package_name = "${pkg}",
    deps = [
${nestedDeps.map(p => `        ${p},`).join('\n')}
    ],
)
`);
      }
    });
  }

  writeRulesForDeps(lock['dependencies'])

  fs.writeFileSync('BUILD.bazel', rootBuild.join('\n'));

  return 0;
}


if (require.main == module) {
  (async () => {
    try {
      process.exitCode = await main(process.argv.slice(2));
    } catch (e) {
      console.error('FAILED', e);
      process.exitCode = 1;
    }
  })();
}
