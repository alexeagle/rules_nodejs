# BEGIN-INTERNAL
# avoid leaking dependencies
load("//:index.bzl", "nodejs_binary")
load(":npm_install_tarballs.bzl", "npm_install_tarballs")
load("//internal/common:copy_to_bin.bzl", "copy_to_bin")

# _RUNTIME_DEPS = ["@npm//@npmcli/arborist"]

# ts_project(
#     name = "typecheck",
#     srcs = ["generate_build_file.ts"],
#     deps = _RUNTIME_DEPS + [
#         "@npm//@types/node",
#     ],
#     tsconfig = {
#         "compilerOptions": {
#             "moduleResolution": "node",
#             "target": "ES2017",
#             "strict": True,
#         },
#     },
# )

# rollup_bundle(
#     name = "bundle",
#     config_file = "rollup.config.js",
#     entry_point = "generate_build_file.js",
#     format = "cjs",
#     sourcemap = "hidden",
#     deps = _RUNTIME_DEPS + [
#         "@npm//@rollup/plugin-commonjs",
#         "@npm//@rollup/plugin-json",
#         "@npm//@rollup/plugin-node-resolve",
#     ],
# )

# terser_minified(
#     name = "bundle.min",
#     src = "bundle.js",
#     sourcemap = False,
# )

# Even after all that - it's just too big at 1.3MB
# % ls -alH dist/bin/internal/npm_fetch_tarballs/bundle.min.js
# -r-xr-xr-x  1 alex.eagle  wheel  1345717 Feb  6 08:36 dist/bin/internal/npm_fetch_tarballs/bundle.min.js
# doubles the size of our distro :(
# generated_file_test(
#     name = "checked_in",
#     generated = "bundle",
#     src = "index.js",
# )

# END-INTERNAL

###
# Testing and demonstration
###

load("//internal/node:directory_entry_point.bzl", "directory_entry_point")

# Run `npm install`
npm_install_tarballs(
    name = "node_modules",
    packages = [
        # demo of installing a first-party tarball from `npm pack`??
        "@deps//shelljs",
        "@deps//terser",
    ],
)

# load("@deps//typescript:index.bzl", "tsc")

# To resolve node_modules, the script with the 'require' statement should be in the output tree
# where the node_modules directory was created.
copy_to_bin(
    name = "entry_point_in_bindir",
    srcs = ["hello_world.js"],
)

# Now we just call `node bazel-out/arch/bin/path/to/hello_world.js` and it will find shelljs in
# bazel-out/arch/bin/path/to/node_modules/shelljs
genrule(
    name = "call_in_bindir",
    srcs = [],
    outs = ["out1"],
    cmd = "NODE_DEBUG=module $(execpath //toolchains/node:node_bin) $(execpath :entry_point_in_bindir) >$@",
    toolchains = ["@build_bazel_rules_nodejs//toolchains/node:toolchain"],
    tools = [
        ":entry_point_in_bindir",
        ":node_modules",
        "//toolchains/node:node_bin",
    ],
)

# An alternate way is to use the NODE_PATH environment variable to point node at where the modules were placed
genrule(
    name = "use_node_path",
    srcs = [],
    outs = ["out2"],
    cmd = "NODE_PATH=$(execpath :node_modules) $(execpath //toolchains/node:node_bin) $(execpath hello_world.js) >$@",
    toolchains = ["@build_bazel_rules_nodejs//toolchains/node:toolchain"],
    tools = [
        ":hello_world.js",
        ":node_modules",
        "//toolchains/node:node_bin",
    ],
)

# A binary target using a first-party entry point
nodejs_binary(
    name = "first_party_bin",
    data = [":node_modules"],
    entry_point = "hello_world.js",
)

genrule(
    name = "use_nodejs_binary",
    srcs = [],
    outs = ["out3"],
    cmd = "$(execpath :first_party_bin) >$@",
    tools = [":first_party_bin"],
)

directory_entry_point(
    name = "call_terser",
    directory = ":node_modules",
    path = "terser/bin/thing.js",
)

# npm_package_bin(
#     name = "run_terser",
#     outs = ["minified.js"],
#     args = [
#         "$(execpath terser_input.js)",
#         "--output",
#         "$@",
#     ],
#     data = [
#         #":node_modules",
#         "terser_input.js",
#     ],
#     # bike-shed these two names
#     # entry_point = ":node_modules",
#     # entry_point_subpath = "terser",
#     tool = "call_terser",
# )

nodejs_binary(
    name = "run_terser",
    data = [
        ":node_modules",
    ],
    entry_point = "call_terser",
)
